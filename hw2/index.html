<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c3{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:468pt;border-top-color:#000000;border-bottom-style:solid}.c21{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:18pt;font-family:"Times New Roman";font-style:normal}.c12{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center;height:11pt}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c9{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c22{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-style:normal}.c14{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c4{vertical-align:sub;font-size:14pt;font-family:"Times New Roman";font-style:italic;font-weight:400}.c5{color:#000000;text-decoration:none;vertical-align:baseline;font-style:normal}.c17{border-spacing:0;border-collapse:collapse;margin-right:auto}.c18{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c0{font-size:12pt;font-family:"Times New Roman";font-style:italic;font-weight:400}.c13{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:center}.c16{font-size:14pt;font-family:"Times New Roman";font-weight:700}.c6{font-weight:700;font-size:12pt;font-family:"Times New Roman"}.c10{font-size:14pt;font-family:"Times New Roman";font-weight:400}.c2{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c23{color:#000000;text-decoration:none;vertical-align:baseline}.c8{font-weight:700;font-size:16pt;font-family:"Times New Roman"}.c24{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c15{font-weight:400;font-size:11pt;font-family:"Arial"}.c19{color:inherit;text-decoration:inherit}.c11{font-style:italic}.c7{height:0pt}.c20{height:23.5pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c24 doc-content"><div><p class="c1"><span class="c5 c15"></span></p></div><p class="c9"><span class="c21">CS 184: Computer Graphics and Imaging, Spring 2024</span></p><p class="c9"><span class="c8 c22">Project 2: Mesh Editor</span></p><p class="c9"><span class="c5 c8">Euhan Kim and Natalie Wei</span></p><p class="c1"><span class="c5 c8"></span></p><p class="c9"><span class="c18 c2"><a class="c19" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw2/index.html&amp;sa=D&amp;source=editors&amp;ust=1709109592307839&amp;usg=AOvVaw1GpvH3RzNOamyZ7VM41eqH">https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw2/index.html</a></span></p><p class="c9"><span class="c2 c18"><a class="c19" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-euhan123/hw2/index.html&amp;sa=D&amp;source=editors&amp;ust=1709109592308152&amp;usg=AOvVaw21edduc6DQxC5yZQ-JNaCH">https://cal-cs184-student.github.io/hw-webpages-sp24-euhan123/hw2/index.html</a></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c5 c8">Overview</span></p><p class="c12"><span class="c5 c6"></span></p><p class="c14"><span class="c5 c2">For this assignment, we implemented a mesh editor. We began by building simple Bezier curves and surfaces using de Casteljau&rsquo;s algorithm; then, we advanced onto manipulating and upsampling triangle meshes using loop subdivision. With our final product, we are able to load complex 3D models whose meshes we may flip, split, and upsample.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c5 c8">Section I: Bezier Curves and Surfaces</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span class="c5 c16">Task 1: Bezier curves with 1D de Casteljau subdivision</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span class="c6">Briefly explain de Casteljau&#39;s algorithm and how you implemented it in order to evaluate Bezier curves.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">Given a set of points, we can use de Casteljau&rsquo;s algorithm to recursively evaluate a polynomial. De Casteljau&rsquo;s takes in </span><span class="c0">n </span><span class="c2">control points and a parameter </span><span class="c0">t</span><span class="c2">, then uses linear interpolation to compute an intermediate point between each consecutive pair of points. This outputs an updated set of </span><span class="c0">n - 1</span><span class="c2">&nbsp;control points. By recursively evaluating these </span><span class="c0">n - 1</span><span class="c2">&nbsp;control points, the algorithm eventually arrives at one point; this point lies on the Bezier curve at </span><span class="c0">t</span><span class="c2">. </span><span class="c5 c2">Our linear interpolation function is as follows:</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c10">lerp(</span><span class="c10 c11">p</span><span class="c4">1</span><span class="c10 c11">, p</span><span class="c4">2</span><span class="c10 c11">, t</span><span class="c10">) = ((1 - </span><span class="c10 c11">t</span><span class="c10">) * </span><span class="c10 c11">p</span><span class="c4">1</span><span class="c10">) + (</span><span class="c10 c11">t</span><span class="c10">&nbsp;* </span><span class="c10 c11">p</span><span class="c4">2</span><span class="c5 c10">) </span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">We run de Casteljau&rsquo;s across a range of </span><span class="c0">t </span><span class="c2">values </span><span class="c5 c2">until we have a fully evaluated Bezier curve.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Take a look at the provided .bzc files and create your own Bezier curve with 6 control points of your choosing. Use this Bezier curve for your screenshots below.</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 434.67px;"><img alt="" src="images/image23.png" style="width: 624.00px; height: 434.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c6">Show screenshots of each step / level of the evaluation from the original control points down to the final evaluated point. Press E to step through. Toggle C to show the completed Bezier curve as well.</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.efc44e6f762fa45976c5506797bdf42de0b1e29f"></a><a id="t.0"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Step 1</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 467.15px; height: 326.50px;"><img alt="" src="images/image8.png" style="width: 467.15px; height: 326.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.15368ec8c701ecb018fc60c69e380231043ff5f4"></a><a id="t.1"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Step 2</span></p></td></tr><tr class="c20"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 471.00px; height: 328.79px;"><img alt="" src="images/image10.png" style="width: 471.00px; height: 328.79px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.754b5aef03707fb0c51c9ea25634b713e970641e"></a><a id="t.2"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Step 3</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 478.13px; height: 332.72px;"><img alt="" src="images/image26.png" style="width: 478.13px; height: 332.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.1ef06af8d3b8995bc63ddb7c29c349f88352b218"></a><a id="t.3"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Step 4</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 497.00px; height: 345.61px;"><img alt="" src="images/image28.png" style="width: 497.00px; height: 345.61px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.332f76703c8a6da053c18363065e6dd9e4d47036"></a><a id="t.4"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Step 5</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image32.png" style="width: 498.46px; height: 348.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.f8fccdfcf20a4e0296e6dc689dd1877a11735578"></a><a id="t.5"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Completed curve</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image34.png" style="width: 503.40px; height: 353.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Show a screenshot of a slightly different Bezier curve by moving the original control points around and modifying the parameter t via mouse scrolling.</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 433.33px;"><img alt="" src="images/image33.png" style="width: 624.00px; height: 433.33px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c16">Task 2: Bezier Surfaces with Separable 1D de Casteljau</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span class="c6">Briefly explain how de Casteljau algorithm extends to Bezier surfaces and how you implemented it in order to evaluate Bezier surfaces.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">To evaluate Bezier surfaces, we apply the same idea we used to evaluate Bezier curves but in three dimensions instead of two. While we previously considered </span><span class="c0">n </span><span class="c2">control points, we now consider an </span><span class="c0">n </span><span class="c2">x</span><span class="c0">&nbsp;n</span><span class="c2">&nbsp;grid of control points where each row defines a Bezier curve. We use de Casteljau&rsquo;s algorithm to evaluate a single point for each row, parameterized by </span><span class="c0">u</span><span class="c2">. These points constitute our control points for the &ldquo;moving curve.&rdquo; We again evaluate these control points using de Casteljau&rsquo;s, this time with parameter </span><span class="c0">v</span><span class="c2">; the final output is the point on the Bezier surface at parameters </span><span class="c0">u</span><span class="c2">, </span><span class="c0">v</span><span class="c5 c2">. </span></p><p class="c1"><span class="c5 c15"></span></p><p class="c9"><span class="c5 c6">Show a screenshot of bez/teapot.bez (not .dae) evaluated by your implementation.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 434.67px;"><img alt="" src="images/image3.png" style="width: 624.00px; height: 434.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c5 c8">Section II: Triangle Meshes and Half-Edge Data Structure</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c16">Task 3: Area-weighted vertex normals</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Briefly explain how you implemented the area-weighted vertex normals.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">We first located the positions of the given vertex and its neighboring vertices by using the half-edge data structure to iterate through the </span><span class="c2">vertex&rsquo;s incident</span><span class="c5 c2">&nbsp;faces. Using these positions, we found the edges of an incident face, the cross product of which gives us the face&rsquo;s area-weighted normal. We continued to iterate through incident faces until we returned to the given vertex, accumulating the area-weighted normals into a vector. Normalizing this vector gives us the area-weighted normal of the vertex. </span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c6">Show screenshots of dae/teapot.dae (not .bez) comparing teapot shading with and without vertex normals. Use Q to toggle default flat shading and Phong shading.</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.d098357c82db4b067e75aa03f415ae456ffda6c2"></a><a id="t.6"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">With vertex normals</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image13.png" style="width: 502.75px; height: 348.50px; margin-left: -2.14px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image9.png" style="width: 501.10px; height: 348.50px; margin-left: -1.32px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.a59c2706bae758fbff14a2959cad67715648089d"></a><a id="t.7"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Without vertex normals</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image2.png" style="width: 508.59px; height: 353.50px; margin-left: -2.59px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image25.png" style="width: 507.29px; height: 353.50px; margin-left: -1.94px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c16">Task 4: Edge flip</span></p><p class="c1"><span class="c5 c6"></span></p><p class="c9"><span class="c6">Briefly explain how you implemented the edge flip operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">To begin, we created an image to use as a reference for our implementation. The image depicts the correct pointer reassignment following a flip:</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 257.37px;"><img alt="" src="images/image24.jpg" style="width: 624.00px; height: 264.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">First, we checked whether or not the edge was a boundary; if it was, we did not proceed with the flip. Then, we used the half-edge data structure to traverse the mesh from the given edge, loading in every half-edge, vertex, edge, and face. We proceeded to reassign the pointers of each element according to the reference image, regardless of if the pointer had actually been altered by the flip. We used the </span><span class="c0">setNeighbor()</span><span class="c2">&nbsp;function to reassign the </span><span class="c0">next</span><span class="c2">, </span><span class="c0">twin</span><span class="c2">, </span><span class="c0">vertex</span><span class="c2">, </span><span class="c0">edge</span><span class="c2">, and </span><span class="c0">face</span><span class="c2">&nbsp;pointers of each half-edge, then reassigned the </span><span class="c0">halfedge</span><span class="c5 c2">&nbsp;pointers of each vertex, edge, and face.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c6">Show screenshots of the teapot before and after some edge flips.</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.2d7cf27e9b9c3f0c788fa7a119370ff93bf05dcd"></a><a id="t.8"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before edge flips</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image20.png" style="width: 499.13px; height: 348.50px; margin-left: -0.34px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image6.png" style="width: 503.98px; height: 348.50px; margin-left: -2.76px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.c9c3dea879774d0476b052a78834e9332f567d21"></a><a id="t.9"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After edge flips</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image27.png" style="width: 508.12px; height: 353.50px; margin-left: -2.36px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image30.png" style="width: 507.89px; height: 353.50px; margin-left: -2.24px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">Fortunately, debugging was relatively simple. Whenever we found ourselves struggling with pointer assignment, we referred back to our reference image and double-checked that everything still matched up. We also looked through the documentation to ensure that we were traversing the mesh correctly. </span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c16">Task 5: Edge split</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Briefly explain how you implemented the edge split operation and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">To begin, we created an image to use as a reference for our implementation. The image depicts the correct pointer reassignment following a split:</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 624.00px; height: 247.73px;"><img alt="" src="images/image11.jpg" style="width: 624.00px; height: 253.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">Our process was similar to the one we used for flipping edges, but with a key difference: splitting edges required us to instantiate new objects. First, we checked whether or not the edge was a boundary; if it was, we did not proceed with the split. Then, we used the half-edge data structure to traverse the mesh from the given edge, loading in every half-edge, vertex, edge, and face. Following the reference image, we instantiated a new vertex, three new edges, six new half-edges, and two new faces. We determined the position of the new vertex by finding the midpoint of the original edge. We proceeded to reassign the pointers of each element according to the reference image, regardless of if the pointer had actually been altered by the flip. We used the </span><span class="c0">setNeighbor()</span><span class="c2">&nbsp;function to reassign the </span><span class="c0">next</span><span class="c2">, </span><span class="c0">twin</span><span class="c2">, </span><span class="c0">vertex</span><span class="c2">, </span><span class="c0">edge</span><span class="c2">, and </span><span class="c0">face</span><span class="c2">&nbsp;pointers of each half-edge, then reassigned the </span><span class="c0">halfedge</span><span class="c5 c2">&nbsp;pointers of each vertex, edge, and face; we also set the pointers of the new objects here.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c6">Show screenshots of a mesh before and after some edge splits.</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.8196deb6ad78acb50d905a39291c13de90314ec7"></a><a id="t.10"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before edge splits</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image22.png" style="width: 501.10px; height: 348.50px; margin-left: -1.32px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.86cc6bf6956e827aa32aef961e36972b69979c70"></a><a id="t.11"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After edge splits</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image31.png" style="width: 506.29px; height: 353.50px; margin-left: -1.45px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Show screenshots of a mesh before and after a combination of both edge splits and edge flips.</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.d0d87fa645bd6e89506c940d2d612a054d587f3a"></a><a id="t.12"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before edge splits and edge flips</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image22.png" style="width: 501.10px; height: 348.50px; margin-left: -1.32px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.1281dedff9034827e79612ca544e080731e8d105"></a><a id="t.13"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After edge splits and edge flips</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image4.png" style="width: 503.40px; height: 354.81px; margin-left: 0.00px; margin-top: -0.66px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Write about your eventful debugging journey, if you have experienced one.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">Debugging was again not too challenging, as we were able to refer back to our reference image. We encountered some small issues like swapped pointers, but this was resolved by parsing our code and making sure that everything matched up with the image.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c16">Task 6: Loop subdivision for mesh upsampling</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Briefly explain how you implemented the loop subdivision and describe any interesting implementation / debugging tricks you have used.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">We split our implementation of loop subdivision into several steps. In the first step, we computed the positions of the old and new vertices by using the half-edge data structure to traverse the mesh. In this step, we also marked each vertex as &ldquo;old&rdquo; by setting their </span><span class="c0">isNew </span><span class="c2">pointer to false. We iterated through the neighboring vertices of each vertex, accumulating these neighbors&rsquo; positions in </span><span class="c0">neighbor_position_sum</span><span class="c2">. We used the following formula to calculate the new positions, where </span><span class="c0">n</span><span class="c2">&nbsp;is the degree of the vertex and </span><span class="c0">u</span><span class="c2">&nbsp;is 3/16 if </span><span class="c0">n</span><span class="c2">&nbsp;= 3 and 3/(8</span><span class="c0">n</span><span class="c5 c2">) otherwise:</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c10">new position = (1 - </span><span class="c10 c11">n</span><span class="c10">&nbsp;* </span><span class="c10 c11">u</span><span class="c10">) * </span><span class="c10 c11">original_position</span><span class="c10">&nbsp;+ </span><span class="c10 c11">u</span><span class="c10">&nbsp;* </span><span class="c10 c11 c23">neighbor_position_sum</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">These values were stored in the </span><span class="c0">newPosition</span><span class="c2">&nbsp;pointer of the respective vertex. Then, we iterated through the edges of the mesh, setting </span><span class="c0">isNew</span><span class="c2">&nbsp;to false. We calculated the position of a vertex at an edge midpoint with the following formula, where </span><span class="c0">A</span><span class="c2">, </span><span class="c0">B</span><span class="c2">, </span><span class="c0">C</span><span class="c2">, and </span><span class="c0">D</span><span class="c5 c2">&nbsp;are the positions of the vertices: </span></p><p class="c1"><span class="c5 c2"></span></p><p class="c14"><span class="c10">new position = &#8540; * (</span><span class="c10 c11">A</span><span class="c10">&nbsp;+ </span><span class="c10 c11">B</span><span class="c10">) + &#8539; * (</span><span class="c10 c11">C</span><span class="c10">&nbsp;+ </span><span class="c10 c11">D</span><span class="c5 c10">)</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">We also stored these values in the </span><span class="c0">newPosition</span><span class="c2">&nbsp;pointer of the respective edge. </span><span class="c2">We re-iterated through the edges, flipping every edge connecting an old vertex and a new vertex and splitting every old edge connecting two old vertices. Finally, we looped through all of the vertices, setting each </span><span class="c0">position</span><span class="c2">&nbsp;pointer to the value stored at the </span><span class="c0">newPosition</span><span class="c5 c2">&nbsp;pointer.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c6">Take some notes, as well as some screenshots, of your observations on how meshes behave after loop subdivision. What happens to sharp corners and edges? Can you reduce this effect by pre-splitting some edges?</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.aa3ce884602a3243adc074d04926ac80cf2f8891"></a><a id="t.14"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before upsampling</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image19.png" style="width: 498.46px; height: 348.50px; margin-left: 0.00px; margin-top: -0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.9ef5098f7f7fd0f7604914e55af46e548edf69e0"></a><a id="t.15"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling once</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image1.png" style="width: 510.13px; height: 353.50px; margin-left: -3.37px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.6f2f0fa7c15ec7083d78a85fbbac6bdeaac85178"></a><a id="t.16"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling twice</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image17.png" style="width: 507.82px; height: 353.50px; margin-left: -2.21px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.5524603479dab6cd389181b7b8d789c631ac78ea"></a><a id="t.17"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling three times</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image14.png" style="width: 509.36px; height: 353.50px; margin-left: -2.98px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">We can see that sharp corners and edges are increasingly rounded out with each round of upsampling. Although the resulting mesh is far smoother, it is also irreflective of the original mesh. We can reduce this effect by pre-splitting edges, as we demonstrate below on our cube mesh.</span></p><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c6">Load dae/cube.dae. Perform several iterations of loop subdivision on the cube. Notice that the cube becomes slightly asymmetric after repeated subdivisions. Can you pre-process the cube with edge flips and splits so that the cube subdivides symmetrically? Document these effects and explain why they occur. Also explain how your pre-processing helps alleviate the effects.</span></p><p class="c1"><span class="c2 c5"></span></p><a id="t.aa3ce884602a3243adc074d04926ac80cf2f8891"></a><a id="t.18"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before upsampling</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image18.png" style="width: 498.61px; height: 348.50px; margin-left: -0.07px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.9ef5098f7f7fd0f7604914e55af46e548edf69e0"></a><a id="t.19"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling once</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image16.png" style="width: 506.52px; height: 353.50px; margin-left: -1.56px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.6f2f0fa7c15ec7083d78a85fbbac6bdeaac85178"></a><a id="t.20"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling twice</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image29.png" style="width: 506.06px; height: 353.50px; margin-left: -1.33px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.5524603479dab6cd389181b7b8d789c631ac78ea"></a><a id="t.21"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling three times</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image21.png" style="width: 507.89px; height: 353.50px; margin-left: -2.24px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c5 c2">To combat asymmetrical subdivision, we pre-processed the cube mesh by splitting the edge on each face of the cube. We got the following results:</span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.aa3ce884602a3243adc074d04926ac80cf2f8891"></a><a id="t.22"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">Before upsampling</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 498.46px; height: 348.50px;"><img alt="" src="images/image12.png" style="width: 501.17px; height: 348.50px; margin-left: -1.35px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><a id="t.9ef5098f7f7fd0f7604914e55af46e548edf69e0"></a><a id="t.23"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling once</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image5.png" style="width: 508.66px; height: 353.50px; margin-left: -2.63px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.6f2f0fa7c15ec7083d78a85fbbac6bdeaac85178"></a><a id="t.24"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling twice</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image7.png" style="width: 509.42px; height: 353.50px; margin-left: -3.01px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c1"><span class="c5 c2"></span></p><a id="t.5524603479dab6cd389181b7b8d789c631ac78ea"></a><a id="t.25"></a><table class="c17"><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c13"><span class="c5 c6">After upsampling three times</span></p></td></tr><tr class="c7"><td class="c3" colspan="1" rowspan="1"><p class="c14"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 503.40px; height: 353.50px;"><img alt="" src="images/image15.png" style="width: 509.19px; height: 353.50px; margin-left: -2.89px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p></td></tr></table><p class="c1"><span class="c5 c2"></span></p><p class="c9"><span class="c2">The faces of the cube are initially asymmetric, an issue that is exacerbated by subdivision; upsampling an asymmetric mesh increases the severity of such defects. This can be alleviated by splitting the edges beforehand to increase the resolution of the mesh before upsampling, giving it more information to go off of. After we split the edges to create symmetrical faces, the cube subdivides much more symmetrically. </span></p></body></html>
