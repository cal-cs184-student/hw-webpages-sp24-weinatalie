<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ol{margin:0;padding:0}table td,table th{padding:0}.c21{-webkit-text-decoration-skip:none;color:#000000;font-weight:700;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none;font-size:18pt;font-family:"Times New Roman"}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c24{-webkit-text-decoration-skip:none;color:#000000;text-decoration:underline;vertical-align:baseline;text-decoration-skip-ink:none}.c7{font-weight:700;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c9{font-weight:700;font-size:16pt;font-family:"Times New Roman";font-style:normal}.c12{-webkit-text-decoration-skip:none;color:#1155cc;text-decoration:underline;text-decoration-skip-ink:none}.c3{font-size:12pt;font-family:"Times New Roman";font-weight:400}.c2{font-size:14pt;font-family:"Times New Roman";font-weight:400}.c18{font-size:12pt;font-family:"Times New Roman";font-weight:700}.c13{font-size:16pt;font-family:"Times New Roman";font-weight:700}.c6{color:#000000;text-decoration:none;vertical-align:baseline}.c22{font-weight:400;font-size:11pt;font-family:"Arial"}.c16{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c8{font-weight:400;font-size:11pt;font-family:"Times New Roman"}.c14{margin-left:36pt;text-indent:36pt}.c11{font-weight:400;font-family:"Times New Roman"}.c23{color:inherit;text-decoration:inherit}.c17{margin-left:72pt}.c5{height:11pt}.c19{font-style:normal}.c20{vertical-align:sub}.c15{vertical-align:super}.c4{font-style:italic}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c16 doc-content"><div><p class="c0 c5"><span class="c6 c19 c22"></span></p></div><p class="c0"><span class="c19 c21">CS 184: Computer Graphics and Imaging, Spring 2024</span></p><p class="c0"><span class="c9 c24">Project 3: Path Tracer</span></p><p class="c0"><span class="c9 c6">Euhan Kim and Natalie Wei</span></p><p class="c0 c5"><span class="c6 c9"></span></p><p class="c0"><span class="c3 c12"><a class="c23" href="https://www.google.com/url?q=https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw3/index.html&amp;sa=D&amp;source=editors&amp;ust=1710574279709407&amp;usg=AOvVaw0cpUaTrnC_zJZS1C1fJAJr">https://cal-cs184-student.github.io/hw-webpages-sp24-weinatalie/hw3/index.html</a></span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c13">Overview</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c1">For this assignment, we implemented the core routines of a physically-based renderer using a path tracing algorithm. We began by generating camera rays in a 3D environment, then giving those rays the ability to intersect with our models. Next, we simulated direct and global lighting by tracing rays of light through a scene. We also implemented bounding volume hierarchies, giving us the ability to render even complex geometries efficiently. Finally, we implemented adaptive sampling to reduce noise in our images. Our final product is able to render 3D scenes with simulated real-world lighting. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c13">Section I: Ray Generation and Scene Intersection </span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c0"><span class="c18">Walk through the ray generation and primitive intersection parts of the rendering pipeline.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">Given normalized image coordinates, we want to generate a camera ray that passes through the corresponding points. We first converted the image coordinates to camera space coordinates using the following formulas:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c2 c4">cameraX</span><span class="c2">&nbsp;= (</span><span class="c2 c4">x</span><span class="c2">&nbsp;- 0.5) * 2 * </span><span class="c2 c4">tan</span><span class="c2">(((</span><span class="c2 c4">hFov</span><span class="c2">&nbsp;* </span><span class="c2 c4">PI</span><span class="c2 c6 c19">) / 180) * 0.5)</span></p><p class="c10"><span class="c2 c4">cameraY</span><span class="c2">&nbsp;= (</span><span class="c2 c4">y</span><span class="c2">&nbsp;- 0.5) * 2 * </span><span class="c2 c4">tan</span><span class="c2">(((</span><span class="c2 c4">vFov</span><span class="c2">&nbsp;* </span><span class="c2 c4">PI</span><span class="c2 c6 c19">) / 180) * 0.5)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">The camera space is a 3D plane that represents how a camera views the world&mdash;the camera is positioned at the origin, and we define a virtual camera sensor that lies along the </span><span class="c3 c4">Z = -1</span><span class="c3">&nbsp;plane. We want to transform the center of the image at (0.5, 0.5) to the center of the virtual camera at (0, 0, -1). We also scale the x and y-coordinates relative to the bottom left corner of the sensor at (-</span><span class="c3 c4">tan</span><span class="c3">(</span><span class="c3 c4">hFov</span><span class="c3">&nbsp;/ 2), -</span><span class="c3 c4">tan</span><span class="c3">(</span><span class="c3 c4">vFov</span><span class="c3">&nbsp;/ 2), - 1) and the top right corner of the sensor at (</span><span class="c3 c4">tan</span><span class="c3">(</span><span class="c3 c4">hFov</span><span class="c3">&nbsp;/ 2), </span><span class="c3 c4">tan</span><span class="c3">(</span><span class="c3 c4">vFov</span><span class="c3">&nbsp;/ 2), - 1). </span><span class="c3 c4">hFov</span><span class="c3">&nbsp;and </span><span class="c3 c4">vFov</span><span class="c3">&nbsp;represent the field of view angles along the x and y-axes; we must convert them from degrees to radians for use. We then created a new ray with a direction of (</span><span class="c3 c4">cameraX</span><span class="c3">, </span><span class="c3 c4">cameraY</span><span class="c3">, -1) and an origin of </span><span class="c3 c4">pos</span><span class="c3">: the position of the camera </span><span class="c3">in the world</span><span class="c3">&nbsp;space. We multiplied the ray&rsquo;s direction by </span><span class="c3 c4">c2w</span><span class="c3">&mdash;</span><span class="c3">the camera-to-world rotation matrix&mdash;to convert it to world space. Finally, we set the </span><span class="c3 c4">min_t</span><span class="c3">&nbsp;and the </span><span class="c3 c4">max_t</span><span class="c3">&nbsp;of the ray to </span><span class="c3 c4">nClip</span><span class="c3">&nbsp;and </span><span class="c3 c4">fClip</span><span class="c3">&nbsp;respectively, since everything that lies outside the </span><span class="c1">near and far clipping planes is considered invisible to the camera. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">Next, we sampled the integral of radiance for each pixel, allowing us to generate RGB maps. The RGB value of a pixel indicates the direction of the rays that intersect with the pixel </span><span class="c3">in the world</span><span class="c1">&nbsp;space. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">We also implemented ray-triangle and ray-sphere intersection, allowing our rays to interact with primitives in our scene. Each primitive has its own </span><span class="c3 c4">has_intersection</span><span class="c3">&nbsp;and </span><span class="c3 c4">intersect</span><span class="c3">&nbsp;functions. To implement ray-sphere intersection, we first computed the time of intersection </span><span class="c3 c4">t</span><span class="c3">&nbsp;using the quadratic formula. We returned true if </span><span class="c3 c4">t </span><span class="c3">was between </span><span class="c3 c4">min_t</span><span class="c3">&nbsp;and </span><span class="c3 c4">max_t</span><span class="c3">, updating </span><span class="c3 c4">max_t </span><span class="c3">to </span><span class="c3 c4">t</span><span class="c3">&nbsp;as needed. Since a ray can intersect with a sphere up to two times, we picked the closest </span><span class="c3 c4">t</span><span class="c3">&nbsp;still within bounds. We then populated the </span><span class="c3 c4">isect </span><span class="c3">of the sphere with the appropriate values, setting </span><span class="c3 c4">t</span><span class="c3">, the surface normal, the primitive object, and the BSDF. </span><span class="c1">Our implementation of ray-triangle intersection is detailed below.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Explain the triangle intersection algorithm you implemented in your own words.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">To implement triangle intersection, we first computed the time of intersection </span><span class="c3 c4">t</span><span class="c3">&nbsp;using the M&ouml;ller&ndash;Trumbore algorithm. This algorithm also gives us the barycentric coordinates, which we used to interpolate the three vertex normals of the triangle. Once we found a potential </span><span class="c3 c4">t</span><span class="c3">, we checked if it was between </span><span class="c3 c4">min_t </span><span class="c3">and </span><span class="c3 c4">max_t</span><span class="c3">; if it was, we updated </span><span class="c3 c4">max_t </span><span class="c3">to </span><span class="c3 c4">t </span><span class="c3">to ensure that we would discard intersections with further primitives. We also checked that the barycentric coordinates were bounded by 0 and 1. Finally, we populated the </span><span class="c3 c4">isect</span><span class="c3">&nbsp;of the triangle with the appropriate values, setting </span><span class="c3 c4">t</span><span class="c1">, the interpolated surface normal, the primitive object, and the BSDF.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c6 c7">Show images with normal shading for a few small .dae files.</span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.02px; height: 239.14px;"><img alt="" src="images/image2.png" style="width: 437.78px; height: 324.48px; margin-left: -66.33px; margin-top: -42.73px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.00px; height: 239.21px;"><img alt="" src="images/image14.png" style="width: 433.59px; height: 324.49px; margin-left: -64.39px; margin-top: -43.47px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c14"><span class="c3">&nbsp; </span><span class="c3 c4">CBempty.dae</span><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3 c6 c4">CBspheres_lambertian.dae</span></p><p class="c0 c14 c5"><span class="c3 c6 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 316.98px; height: 248.50px;"><img alt="" src="images/image40.png" style="width: 462.78px; height: 342.14px; margin-left: -72.76px; margin-top: -47.44px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span class="c3 c6 c4">CBcoil.dae</span></p><p class="c10 c5"><span class="c7 c6"></span></p><p class="c10"><span class="c9 c6">Section II: Bounding Volume Hierarchy</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">To construct the BVH, we first iterated through all of the given primitives, computing a bounding box for each one. We used these bounding boxes to create a BBox of all of the primitives, which we then used to initialize a new BVHNode. The node is a child node if the number of primitives in the BBox is less than or equal to </span><span class="c3 c4">max_leaf_size</span><span class="c3">, and a leaf node otherwise. Our heuristic was the average centroid of all of the primitives sorted on the largest axis of the BBox. If a primitive&rsquo;s centroid along the chosen axis was less than the heuristic, we sorted it into a left vector; the other primitives were sorted into a right vector. If all of the primitives ended up in the same vector, we split it in half to prevent an infinite loop. Finally, we recursed on the left and right vectors to create our left and right subtrees. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">The following images show a partial BVH traversal of </span><span class="c3 c4">cow.dae</span><span class="c1">:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.96px; height: 238.51px;"><img alt="" src="images/image35.png" style="width: 306.96px; height: 238.51px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.50px; height: 240.19px;"><img alt="" src="images/image1.png" style="width: 306.50px; height: 240.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.51px; height: 239.50px;"><img alt="" src="images/image20.png" style="width: 308.51px; height: 239.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.50px; height: 240.53px;"><img alt="" src="images/image37.png" style="width: 306.50px; height: 240.53px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.16px; height: 241.04px;"><img alt="" src="images/image25.png" style="width: 308.16px; height: 241.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 240.52px;"><img alt="" src="images/image45.png" style="width: 307.50px; height: 240.52px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">We can observe that at each step, approximately half of the primitives are discarded. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Show images with normal shading for a few large .dae files that you can only render with BVH acceleration.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images were rendered on 8 threads:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 230.25px;"><img alt="" src="images/image38.png" style="width: 307.00px; height: 230.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.00px; height: 230.00px;"><img alt="" src="images/image43.png" style="width: 307.00px; height: 230.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c17"><span class="c3">&nbsp; &nbsp; </span><span class="c3 c4">maxplanck.dae</span><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span class="c3 c6 c4">beast.dae</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.50px; height: 239.82px;"><img alt="" src="images/image34.png" style="width: 446.78px; height: 336.03px; margin-left: -71.60px; margin-top: -49.54px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 310.24px; height: 239.50px;"><img alt="" src="images/image29.png" style="width: 469.88px; height: 350.31px; margin-left: -80.57px; margin-top: -55.23px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0 c17"><span class="c3">&nbsp; &nbsp;</span><span class="c3 c4">CBdragon.dae</span><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBlucy.dae</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Compare rendering times on a few scenes with moderately complex geometries with and without BVH acceleration. Present your results in a one-paragraph analysis.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">We experienced the largest speedup when rendering </span><span class="c3 c4">CBlucy.dae</span><span class="c3">, which took 472.559 seconds without BVH acceleration and only 0.0019 seconds with&mdash;that&rsquo;s a speedup of almost 250,000 times! Similarly, </span><span class="c3 c4">CBdragon.dae</span><span class="c3">&nbsp;took 303.348 seconds before and 0.0501 seconds after, </span><span class="c3 c4">beast.dae</span><span class="c3">&nbsp;took 198.032 seconds before and 0.0484 seconds after, and </span><span class="c3 c4">maxplanck.dae</span><span class="c3">&nbsp;took 124.910 seconds before and 0.0678 seconds after. BVH is able to take ray </span><span class="c3">intersection</span><span class="c1">&nbsp;from a linear runtime to a logarithmic runtime, resulting in the significant speedups we experienced. This is because we can discard all of the primitives in a bounding box if it does not have an intersection&mdash;otherwise, we would have to check each primitive individually. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c9 c6">Section III: Direct Illumination</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Walk through both implementations of the direct lighting function.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">To implement uniform hemisphere sampling, we used a sampling loop. In each iteration, we took a random sample </span><span class="c3 c4">wi </span><span class="c3">of the unit hemisphere using </span><span class="c3 c4">hemisphereSampler-&gt;get_sample()</span><span class="c3">. Then, we converted </span><span class="c3 c4">wi</span><span class="c3">&nbsp;</span><span class="c3">to the world</span><span class="c3">&nbsp;space by </span><span class="c3">multiplying it with </span><span class="c3 c4">o2w</span><span class="c3">, the object-to-world rotation matrix. We created a new ray with a direction of </span><span class="c3 c4">wi </span><span class="c3">and </span><span class="c3">an origin at the hit point; if the ray intersected the BVH, we used </span><span class="c3 c4">intersect.bsdf-&gt;get_emission()</span><span class="c3">&nbsp;to get the emission of the surface at the new intersection. We also found the emission of the given intersection, accumulating the initial emission times the new emission times cosine of </span><span class="c3 c4">wi</span><span class="c3">&nbsp;all over </span><span class="c3">the </span><span class="c3 c4">pdf</span><span class="c3">&mdash;</span><span class="c3">0.5 * </span><span class="c3 c4">PI</span><span class="c3">&mdash;into our outgoing lighting. </span><span class="c3">We ran the sampling loop </span><span class="c3 c4">num_samples</span><span class="c3">&nbsp;times and returned the outgoing lighting averaged over </span><span class="c3 c4">num_samples</span><span class="c1">.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">To implement importance sampling, we iterated over each SceneLight in a scene. We sampled the radiance using </span><span class="c3 c4">SceneLight::sample_L()</span><span class="c3">, which also writes to a direction </span><span class="c3">vector </span><span class="c3 c4">wi</span><span class="c3 c4">&nbsp;</span><span class="c3">and a </span><span class="c3 c4">pdf</span><span class="c3">. Then, we converted </span><span class="c3 c4">wi</span><span class="c3">&nbsp;</span><span class="c3">to the world</span><span class="c3">&nbsp;space by multiplying it with </span><span class="c3 c4">o2w</span><span class="c3">, the object-to-world rotation matrix. We created a new ray with a direction of </span><span class="c3 c4">wi </span><span class="c3">and an origin at the hit point, setting </span><span class="c3 c4">max_t</span><span class="c3">&nbsp;to its distance from the light source. If the ray intersected the BVH, we used </span><span class="c3 c4">intersect.bsdf-&gt;get_emission()</span><span class="c3">&nbsp;to get the emission at the intersection. We computed the emission times the radiance times </span><span class="c3">cosine of </span><span class="c3 c4">wi</span><span class="c3">&nbsp;over</span><span class="c3">&nbsp;the </span><span class="c3 c4">pdf</span><span class="c3">, then averaged over </span><span class="c3 c4">num_samples</span><span class="c3">&nbsp;and accumulated the result </span><span class="c3">into our outgoing lighting. We iterated over a light </span><span class="c3 c4">ns_area_light </span><span class="c3">times (1 time for delta lights) before returning the outgoing lighting.</span><span class="c1">&nbsp;</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Show some images rendered with both implementations of the direct lighting function.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images were rendered on 8 threads with 32 light rays and 64 samples:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.29px; height: 227.19px;"><img alt="" src="images/image6.png" style="width: 305.29px; height: 227.19px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 304.00px; height: 227.26px;"><img alt="" src="images/image11.png" style="width: 304.00px; height: 227.26px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c3 c4">CBbunny.dae (uniform sampling)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span><span class="c3 c6 c4">CBbunny.dae (importance sampling)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image33.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image15.png" style="width: 305.66px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; </span><span class="c11 c4">CBspheres_lambertian.dae (uniform sampling)</span><span class="c11">&nbsp; &nbsp; &nbsp;</span><span class="c11 c4">CBspheres_lambertian.dae (importance sampling)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Compare the results between uniform hemisphere sampling and lighting sampling in a one-paragraph analysis.</span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c0"><span class="c1">Although the images were rendered with the same number of light rays and samples, there are noticeable differences between uniform and importance sampling. In uniform sampling, we sample in random directions around a point, so only a small proportion of rays actually intersect with a light source. This leads to the noisiness we can observe above. Meanwhile, importance sampling samples all lights directly and thus only considers intersecting rays, creating a much smoother image. Given the same sample rate, importance sampling provides us with more information to shade the scene than uniform sampling. </span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c0"><span class="c7 c6">Focus on one particular scene with at least one area light and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and with 1 sample per pixel (the -s flag) using light sampling, not uniform hemisphere sampling.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">The following images were rendered on 8 threads with 1 sample: </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.00px; height: 229.25px;"><img alt="" src="images/image10.png" style="width: 305.00px; height: 229.25px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.50px; height: 228.91px;"><img alt="" src="images/image28.png" style="width: 306.50px; height: 228.91px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span><span class="c3 c4">CBbunny.dae (1 light ray)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="c3 c4">CBbunny.dae (4 light rays)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.10px; height: 227.82px;"><img alt="" src="images/image18.png" style="width: 307.10px; height: 227.82px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.50px; height: 227.87px;"><img alt="" src="images/image39.png" style="width: 303.50px; height: 227.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (16 light rays)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3 c4">CBbunny.dae (64 light rays)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">We can observe that using more light rays denoises the image. The image rendered with only 1 light ray is very noisy, with harsh, pixelated, and barely </span><span class="c3">gradated</span><span class="c1">&nbsp;shadows. As more light rays are used, the shadows grow increasingly soft and smooth. This is because the more samples taken per area light, the more information we have to shade the scene. However, there do appear to be diminishing returns after a certain point&mdash;the difference between the images rendered using 16 &nbsp;and 64 light rays is noticeable, but small.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c13">Section IV: Global Illumination </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Walk through your implementation of the indirect lighting function.</span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c0"><span class="c3">First, we sampled the outgoing radiance </span><span class="c3 c4">w_out</span><span class="c3">&nbsp;with </span><span class="c3 c4">sample_f()</span><span class="c3">&nbsp;and wrote to the direction of the ingoing radiance </span><span class="c3 c4">w_in </span><span class="c3">and a </span><span class="c3 c4">pdf</span><span class="c3">. </span><span class="c3">Then, we converted </span><span class="c3 c4">w_in</span><span class="c3">&nbsp;</span><span class="c3">to the world</span><span class="c3">&nbsp;space by multiplying it with </span><span class="c3 c4">o2w</span><span class="c3">, the object-to-world rotation matrix. We created a new ray with a direction of </span><span class="c3 c4">w_in </span><span class="c3">and an origin at the hit point, decrementing its depth by 1. If the ray intersected the BVH, we used </span><span class="c3 c4">intersect.bsdf-&gt;get_emission()</span><span class="c3">&nbsp;to get the emission at the intersection. We computed the radiance by </span><span class="c3">recursing</span><span class="c3">&nbsp;</span><span class="c3">on the ray. We took this result times the outgoing radiance times </span><span class="c3">cosine of </span><span class="c3 c4">w_in</span><span class="c3">&nbsp;all over</span><span class="c3">&nbsp;the </span><span class="c3 c4">pdf</span><span class="c3">, </span><span class="c3">accumulating this value into our outgoing lighting. Once the ray&rsquo;s depth was decremented to 0, we returned the outgoing lighting. Finally, we implemented Russian Roulette rendering using </span><span class="c3 c4">coin_flip() </span><span class="c3">to randomly terminate our indirect illumination before reaching </span><span class="c3 c4">max_ray_depth</span><span class="c3">; we used a termination probability of 0.35 and a continuation probability </span><span class="c3">of 0.65. Our global illumination is composed of the zero bounce radiance from </span><span class="c3 c4">zero_bounce_radiance()</span><span class="c3">, the direct illumination from </span><span class="c3 c4">one_bounce_radiance()</span><span class="c3">, and the indirect illumination from </span><span class="c3 c4">at_least_one_bounce_radiance()</span><span class="c3">.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Show some images rendered with global (direct and indirect) illumination. Use 1024 samples per pixel.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images were rendered on 8 threads with 16 light rays, 1024 samples, and a max depth of 5:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image5.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.38px; height: 231.04px;"><img alt="" src="images/image9.png" style="width: 307.38px; height: 231.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c11 c4">CBspheres_lambertian.dae</span><span class="c11">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CBbunny</span><span class="c11 c4">.dae</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. Use 1024 samples per pixel. (You will have to edit PathTracer::at_least_one_bounce_radiance(...) in your code to generate these views.)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">The following images were rendered on 8 threads with 16 light rays, 1024 samples, and a max depth of 2:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.50px; height: 223.45px;"><img alt="" src="images/image4.png" style="width: 298.50px; height: 223.88px; margin-left: 0.00px; margin-top: -0.21px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 298.50px; height: 223.45px;"><img alt="" src="images/image22.png" style="width: 298.50px; height: 223.88px; margin-left: 0.00px; margin-top: -0.21px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; </span><span class="c11 c4">CBspheres_lambertian.dae (direct illumination)</span><span class="c11">&nbsp; &nbsp; </span><span class="c11 c4">CBspheres_lambertian.dae (indirect illumination)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">Direct illumination is the lighting from the first bounce, while indirect illumination is the lighting from all subsequent bounces. We can observe that parts of the scene, such as the underside of the spheres and the ceiling, are lit only through indirect illumination. Indirect illumination also includes ambient lighting from the walls. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">For CBbunny.dae, render the mth bounce of light with max_ray_depth set to 0, 1, 2, 3, 4, and 5 (the -m flag), and isAccumBounces=false. Explain in your writeup what you see for the 2nd and 3rd bounce of light, and how it contributes to the quality of the rendered image compared to rasterization. Use 1024 samples per pixel.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images were rendered on 8 threads with 16 light rays and 1024 samples:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.21px; height: 228.72px;"><img alt="" src="images/image3.png" style="width: 303.21px; height: 228.72px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.41px; height: 229.29px;"><img alt="" src="images/image31.png" style="width: 307.41px; height: 229.29px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 0)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 1)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.21px; height: 228.72px;"><img alt="" src="images/image24.png" style="width: 304.96px; height: 228.72px; margin-left: -0.87px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.41px; height: 229.29px;"><img alt="" src="images/image32.png" style="width: 307.41px; height: 230.56px; margin-left: 0.00px; margin-top: -0.63px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 2)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 3)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 303.21px; height: 228.72px;"><img alt="" src="images/image51.png" style="width: 304.96px; height: 228.72px; margin-left: -0.87px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.41px; height: 229.29px;"><img alt="" src="images/image17.png" style="width: 307.41px; height: 230.56px; margin-left: 0.00px; margin-top: -0.63px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 4)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 5)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c0"><span class="c1">The images rendered with a depth of 0 and a depth of 1 appear as expected; these images contain only zero bounce illumination or direct illumination, respectively. However, we can observe that the images grow darker with each additional bounce, as less rays remain. The image rendered with a depth of 2 has indirect lighting on the underside of the bunny and the ceiling. The image rendered with a depth of 3 is barely lit in comparison, but still contains some indirect lighting in its colored shadows. Path tracing allows us to layer lighting from additional bounces and render more realistic scenes than would be possible using just surface normals. We would not be able to achieve these dynamic effects with rasterization, which is object-based&mdash;we would be simply drawing the object in instead of tracking the light itself. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">For CBbunny.dae, compare rendered views with max_ray_depth set to 0, 1, 2, 3, 4, and 5(the -m flag). Use 1024 samples per pixel.</span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c0"><span class="c3">The following images were rendered on 8 threads with 16 light rays and 1024 samples:</span></p><p class="c0 c5"><span class="c7 c6"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.56px; height: 231.67px;"><img alt="" src="images/image3.png" style="width: 306.56px; height: 231.67px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 231.87px;"><img alt="" src="images/image12.png" style="width: 307.50px; height: 231.87px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 0)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 1)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.31px; height: 230.50px;"><img alt="" src="images/image16.png" style="width: 305.31px; height: 230.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.00px; height: 230.50px;"><img alt="" src="images/image27.png" style="width: 308.00px; height: 230.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 2)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 3)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.26px; height: 230.96px;"><img alt="" src="images/image19.png" style="width: 308.26px; height: 230.96px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.38px; height: 231.04px;"><img alt="" src="images/image9.png" style="width: 307.38px; height: 231.04px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 4)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 5)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c0"><span class="c1">We only have zero bounce illumination at a depth of 0. Upon increasing to a depth of 1, we accumulate both zero bounce and direct illumination. As the depth continues to increase, we introduce more indirect illumination to the scene. This causes areas that are almost completely black at a depth of 1&mdash;like the ceiling and the bunny&rsquo;s shadow&mdash;to grow lighter. We can also observe ambient lighting from the walls seeping into the shadows.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">For CBbunny.dae, output the Russian Roulette rendering with max_ray_depth set to 0, 1, 2, 3, 4, and 100(the -m flag). Use 1024 samples per pixel.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images were rendered on 8 threads with 16 light rays and 1024 samples:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.56px; height: 231.67px;"><img alt="" src="images/image36.png" style="width: 308.89px; height: 231.67px; margin-left: -1.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.50px; height: 231.87px;"><img alt="" src="images/image49.png" style="width: 309.16px; height: 231.87px; margin-left: -0.83px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 0)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 1)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.31px; height: 230.50px;"><img alt="" src="images/image48.png" style="width: 307.33px; height: 230.50px; margin-left: -1.01px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.00px; height: 230.50px;"><img alt="" src="images/image44.png" style="width: 308.00px; height: 231.00px; margin-left: 0.00px; margin-top: -0.25px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 2)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c3 c6 c4">CBbunny.dae (depth of 3)</span></p><p class="c0 c5"><span class="c3 c6 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 308.26px; height: 230.96px;"><img alt="" src="images/image42.png" style="width: 308.26px; height: 231.20px; margin-left: 0.00px; margin-top: -0.12px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 307.38px; height: 231.04px;"><img alt="" src="images/image23.png" style="width: 308.05px; height: 231.04px; margin-left: -0.33px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</span><span class="c3 c4">CBbunny.dae (depth of 4)</span><span class="c3">&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c3 c4">CBbunny.dae (depth of 100)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">With our Russian Roulette implementation, the additional time needed to render higher ray depths increases significantly less. For example, without Russian Roulette, an image with a ray depth of 100 would have been practically unrenderable.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">The following images are rendered on 8 threads with 4 light rays and a max depth of 5:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image30.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image13.png" style="width: 306.00px; height: 229.50px; margin-left: -0.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c11 c4">CBspheres_lambertian.dae (1 sample)</span><span class="c11">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span><span class="c6 c8 c4">CBspheres_lambertian.dae (2 samples)</span></p><p class="c0 c5"><span class="c6 c8 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image46.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image41.png" style="width: 306.00px; height: 229.50px; margin-left: -0.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11 c4">CBspheres_lambertian.dae (4 samples)</span><span class="c11">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; </span><span class="c6 c8 c4">CBspheres_lambertian.dae (8 samples)</span></p><p class="c0 c5"><span class="c6 c8 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image47.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image50.png" style="width: 306.00px; height: 229.50px; margin-left: -0.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="c11 c4">CBspheres_lambertian.dae (16 samples)</span><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c6 c8 c4">CBspheres_lambertian.dae (64 samples)</span></p><p class="c0 c5"><span class="c6 c8 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image5.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c10"><span class="c6 c8 c4">CBspheres_lambertian.dae (1024 samples)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">We can observe that the sampling rate dramatically affects the smoothness of an image. Lower sampling rates&mdash;especially those under 16&mdash;produced very grainy and noisy images. Meanwhile, higher sampling rates produced increasingly clean results. The image rendered with a sampling rate of 1024 is by far the smoothest, containing barely any noise. However, as the sampling rate increased, so did the time taken to render the image. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c13">Section V: Adaptive Sampling </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c7 c6">Explain adaptive sampling. Walk through your implementation of adaptive sampling.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">In adaptive sampling, we concentrate our samples in areas where pixels converge slowly and reduce our samples in areas where pixels converge quickly. By focusing on areas that tend to have more noise, we can produce smoother images at less of a computational cost than if we were sampling uniformly. To implement adaptive sampling we used the following formulas:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span class="c2 c4">I</span><span class="c2">&nbsp;= 1.96 * (</span><span class="c2 c4">&sigma;</span><span class="c2">&nbsp;/ (</span><span class="c2 c4">n</span><span class="c2 c15">0.5</span><span class="c2 c6 c19">))</span></p><p class="c10"><span class="c2 c4">&mu; </span><span class="c2">= </span><span class="c2 c4">s</span><span class="c2 c20 c4">1</span><span class="c2">&nbsp;/ </span><span class="c2 c6 c4">n</span></p><p class="c10"><span class="c2 c4">&sigma;</span><span class="c2 c15">2 </span><span class="c2">= (1 / (</span><span class="c2 c4">n</span><span class="c2">&nbsp;- 1)) * (</span><span class="c2 c4">s</span><span class="c2 c20">2</span><span class="c2">&nbsp;- ((</span><span class="c2 c4">s</span><span class="c2 c4 c20">1</span><span class="c2">)</span><span class="c2 c15">2</span><span class="c2">&nbsp;/ </span><span class="c2 c4">n</span><span class="c2">))</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3 c4">s</span><span class="c3 c20">1</span><span class="c3">&nbsp;and </span><span class="c3 c4">s</span><span class="c3 c20">2</span><span class="c3 c15">&nbsp;</span><span class="c3">are the summations of the radiance and the squared radiance of each ray, respectively. </span><span class="c3">Here, </span><span class="c3 c4">I</span><span class="c3">&nbsp;</span><span class="c3">measures</span><span class="c3">&nbsp;a pixel&rsquo;s convergence; a smaller </span><span class="c3 c4">I </span><span class="c3">value means that it is more likely that the pixel has converged. We checked whether </span><span class="c3 c4">I </span><span class="c3">was less than or equal to </span><span class="c3 c4">maxTolerance</span><span class="c3">&nbsp;times </span><span class="c3 c4">&mu;</span><span class="c3">, where </span><span class="c3 c4">maxTolerance</span><span class="c1">&nbsp;= 0.05. If this condition was satisfied, then we assumed that the pixel had already converged and terminated our sampling loop early. </span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c18">Pick two scenes and render them with at least 2048 samples per pixel. Show a good sampling rate image with clearly visible differences in sampling rate over various regions and pixels. Include both your sample rate image, which shows how your adaptive sampling changes depending on which part of the image you are rendering, and your noise-free rendered result. Use 1 sample per light and at least 5 for max ray depth.</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c3">The following images were rendered on 8 threads with 1 light ray, 2048 samples and a max depth of 5:</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image26.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image21.png" style="width: 306.00px; height: 229.50px; margin-left: -0.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; </span><span class="c11 c4">CBspheres_lambertian.dae</span><span class="c11">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span><span class="c6 c4 c8">CBspheres_lambertian.dae (sampling rate)</span></p><p class="c0 c5"><span class="c6 c8 c4"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 306.00px; height: 229.50px;"><img alt="" src="images/image7.png" style="width: 306.00px; height: 229.50px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 305.66px; height: 229.50px;"><img alt="" src="images/image8.png" style="width: 306.00px; height: 229.50px; margin-left: -0.17px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp;</span><span class="c11 c4">CBbunny.dae</span><span class="c11">&nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c11 c4">CBbunny.dae (sampling rate)</span></p><p class="c0 c5"><span class="c1"></span></p><p class="c0"><span class="c1">We can observe that areas of the image with a higher sampling rate, like the objects themselves, are red, while areas with a lower sampling rate, like the ceiling and walls, are blue. </span></p></body></html>
